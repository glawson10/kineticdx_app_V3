import * as admin from "firebase-admin";
import { CallableRequest, HttpsError } from "firebase-functions/v2/https";
import PDFDocument from "pdfkit";
import crypto from "crypto";

import { requireActiveMemberWithPerm } from "../authz";
import { writeAuditEvent } from "./audit";

type Input = {
  clinicId: string;
  from?: string; // ISO
  to?: string; // ISO
  limit?: number; // optional cap (default 500)
};

function safeStr(v: unknown): string {
  return (v ?? "").toString().trim();
}

function safeDate(v: unknown): Date | null {
  const s = safeStr(v);
  if (!s) return null;
  const d = new Date(s);
  if (Number.isNaN(d.getTime())) return null;
  return d;
}

export async function exportAuditPdf(req: CallableRequest<Input>) {
  if (!req.auth) throw new HttpsError("unauthenticated", "Sign in required.");

  const clinicId = safeStr(req.data?.clinicId);
  if (!clinicId) throw new HttpsError("invalid-argument", "clinicId required");

  const from = safeDate(req.data?.from);
  const to = safeDate(req.data?.to);
  const limit = Math.max(1, Math.min(2000, Number(req.data?.limit ?? 500)));

  const db = admin.firestore();
  const uid = req.auth.uid;

  await requireActiveMemberWithPerm(db, clinicId, uid, "audit.read");

  // ─────────────────────────────
  // Load audit events
  // ─────────────────────────────
  let q: FirebaseFirestore.Query = db
    .collection("clinics")
    .doc(clinicId)
    .collection("audit")
    .orderBy("createdAt", "desc")
    .limit(limit);

  // Firestore can accept JS Date for Timestamp comparisons
  if (from) q = q.where("createdAt", ">=", from);
  if (to) q = q.where("createdAt", "<=", to);

  const snap = await q.get();
  const events = snap.docs.map((d) => ({ id: d.id, ...(d.data() as any) }));

  // ─────────────────────────────
  // Build PDF
  // ─────────────────────────────
  const doc: any = new PDFDocument({ margin: 40 });
  const pdfPromise = collectPdfBuffer(doc);

  header(doc, "Audit log export");

  kv(doc, "Clinic ID", clinicId);
  kv(doc, "Generated by", uid);
  kv(doc, "Generated at", new Date().toISOString());
  kv(doc, "Event count", String(events.length));
  doc.moveDown();

  drawTableHeader(doc);

  for (const e of events) {
    drawRow(doc, e);
  }

  doc.end();

  const buffer = await pdfPromise;

  // ─────────────────────────────
  // Hash (compliance)
  // ─────────────────────────────
  const hash = crypto.createHash("sha256").update(buffer).digest("hex");

  await writeAuditEvent(db, clinicId, {
    type: "audit.exported",
    actorUid: uid,
    metadata: { count: events.length, sha256: hash },
  });

  return {
    ok: true,
    mimeType: "application/pdf",
    base64: buffer.toString("base64"),
    sha256: hash,
  };
}

// ─────────────────────────────
// Helpers
// ─────────────────────────────

function collectPdfBuffer(doc: any): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    doc.on("data", (c: any) => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", reject);
  });
}

function header(doc: any, title: string) {
  doc.fontSize(18).text(title);
  doc.moveDown();
}

function kv(doc: any, k: string, v: string) {
  doc.fontSize(10).text(`${k}: ${v}`);
}

function drawTableHeader(doc: any) {
  doc.moveDown();
  doc.fontSize(11).text("Time | Type | Actor | Metadata");
  doc.moveDown(0.5);
}

function drawRow(doc: any, e: any) {
  const t = e.createdAt?.toDate ? e.createdAt.toDate().toISOString() : "";
  const actor = (e.actorDisplayName ?? e.actorUid ?? "").toString();
  const meta = e.metadata ? safeMeta(e.metadata) : "";

  doc.fontSize(9).text(`${t} | ${e.type} | ${actor} | ${meta}`, { width: 520 });
}

function safeMeta(m: any): string {
  try {
    // keep it compact
    const s = JSON.stringify(m);
    return s.length > 500 ? s.slice(0, 500) + "…" : s;
  } catch {
    return "";
  }
}
